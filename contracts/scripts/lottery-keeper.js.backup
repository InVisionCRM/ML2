/**
 * PulseChain SuperStakeLottery6of55 V2 Keeper
 *
 * Simplified keeper that buys tickets every 135 seconds (2:15 minutes)
 * This automatically finalizes expired rounds and ensures rounds have activity
 *
 * Requirements:
 * - PRIVATE_KEY in .env (any funded key; function is permissionless)
 * - LOTTERY_ADDRESS in .env (defaults to mainnet address)
 * - Optional: PULSECHAIN_RPC, KEEPER_GAS_LIMIT
 *
 * Usage: node scripts/lottery-keeper.js
 */

require('dotenv').config()
const { ethers } = require('ethers')
const path = require('path')
const fs = require('fs')

// Config
const RPC_URL = process.env.PULSECHAIN_RPC || 'https://rpc.pulsechain.com'
const PRIVATE_KEY = process.env.PRIVATE_KEY

// ‚ö†Ô∏è IMPORTANT: Set your deployed lottery contract address here or in .env
// Latest deployment: 0xf976eb6A6CD1139d2550eb20Af1542D640BcB06C (Block 25267656)
// Get from: lib/contracts.ts or your deployment logs
const LOTTERY_ADDRESS =
  process.env.LOTTERY_ADDRESS || '0xf976eb6A6CD1139d2550eb20Af1542D640BcB06C'

const GAS_LIMIT = parseInt(process.env.KEEPER_GAS_LIMIT || '2000000', 10)

if (!PRIVATE_KEY) {
  console.error('‚ùå Missing PRIVATE_KEY in .env')
  process.exit(1)
}

// Load ABI (supports Hardhat artifact shape)
const abiPath = path.join(__dirname, '../../abi/lottery6of55-v2.json')
let ABI
try {
  const artifact = JSON.parse(fs.readFileSync(abiPath, 'utf8'))
  ABI = Array.isArray(artifact) ? artifact : artifact.abi
} catch (err) {
  console.error('‚ùå Failed to load lottery ABI:', err.message)
  console.error('   Expected at:', abiPath)
  process.exit(1)
}

function generateRandomTicketNumbers() {
  const numbers = new Set()
  while (numbers.size < 6) {
    // Generate random number between 1-55
    const num = Math.floor(Math.random() * 55) + 1
    numbers.add(num)
  }
  return Array.from(numbers).sort((a, b) => a - b)
}

async function main() {
  const provider = new ethers.JsonRpcProvider(RPC_URL)
  const wallet = new ethers.Wallet(PRIVATE_KEY, provider)
  const lottery = new ethers.Contract(LOTTERY_ADDRESS, ABI, wallet)

  const MORBIUS_TOKEN_ADDRESS = '0xB7d4eB5fDfE3d4d3B5C16a44A49948c6EC77c6F1'
  const ERC20_ABI = [
    'function balanceOf(address) view returns (uint256)',
    'function symbol() view returns (string)',
    'function decimals() view returns (uint8)',
    'function allowance(address owner, address spender) view returns (uint256)',
    'function approve(address spender, uint256 amount) returns (bool)'
  ]
  const morbiusToken = new ethers.Contract(MORBIUS_TOKEN_ADDRESS, ERC20_ABI, provider)

  // Get initial balances
  try {
    const morbiusBalance = await morbiusToken.balanceOf(wallet.address)
    const plsBalance = await provider.getBalance(wallet.address)
    console.log('ü§ñ Lottery Keeper Started')
    console.log('‚îÅ'.repeat(50))
    console.log(`Keeper Address: ${wallet.address}`)
    console.log(`Contract: ${LOTTERY_ADDRESS}`)
    console.log(`RPC: ${RPC_URL}`)
    console.log('üí∞ Initial Balances:')
    console.log(`   PLS: ${ethers.formatEther(plsBalance)} PLS`)
    console.log(`   Morbius: ${ethers.formatUnits(morbiusBalance, 18)} MORBIUS`)
    console.log('‚îÅ'.repeat(50) + '\n')
  } catch (err) {
    console.error('‚ö†Ô∏è  Could not fetch initial balances:', err.message, '\n')
  }

  let consecutiveErrors = 0
  const MAX_CONSECUTIVE_ERRORS = 10

  // Buy ticket every 135 seconds (2:15 minutes)
  const TICKET_INTERVAL_MS = 135000

  console.log(`üé´ Keeper will buy tickets every ${TICKET_INTERVAL_MS / 1000} seconds`)
  console.log('‚ïê'.repeat(50) + '\n')

  // Set up recurring ticket purchases
  const ticketInterval = setInterval(async () => {
    try {
      console.log(`\n${'‚ïê'.repeat(50)}`)
      console.log(`üé´ BUYING KEEPER TICKET - ${new Date().toLocaleString()}`)
      console.log('‚ïê'.repeat(50))

      // Check keeper balance
      const keeperBalance = await morbiusToken.balanceOf(wallet.address)
      const ticketPrice = await lottery.ticketPriceMorbius()

      console.log(`üí∞ Keeper Balance: ${ethers.formatUnits(keeperBalance, 18)} MORBIUS`)
      console.log(`üé´ Ticket Price: ${ethers.formatUnits(ticketPrice, 18)} MORBIUS`)

      if (keeperBalance >= ticketPrice) {
        console.log(`üõ°Ô∏è Purchasing keeper ticket...`)

        // Check if lottery contract is approved to spend keeper's Morbius
        const currentAllowance = await morbiusToken.allowance(wallet.address, LOTTERY_ADDRESS)
        console.log(`üîì Current Allowance: ${ethers.formatUnits(currentAllowance, 18)} MORBIUS`)

        if (currentAllowance < ticketPrice) {
          console.log(`üìù Approving lottery contract to spend Morbius...`)
          const approveTx = await morbiusToken.connect(wallet).approve(LOTTERY_ADDRESS, ethers.MaxUint256)
          console.log(`üìù Approval Transaction: ${approveTx.hash}`)
          await approveTx.wait()
          console.log(`‚úÖ Approval confirmed`)
        }

        // Generate random numbers for keeper ticket
        const keeperTicketNumbers = generateRandomTicketNumbers()
        const keeperNumbers = [keeperTicketNumbers]

        console.log(`üé≤ Keeper Ticket Numbers: [${keeperTicketNumbers.join(', ')}]`)

        // This will automatically finalize expired rounds and start new ones
        const tx = await lottery.buyTickets(keeperNumbers, { gasLimit: GAS_LIMIT })
        console.log(`üìù Transaction: ${tx.hash}`)
        console.log(`‚è≥ Waiting for confirmation...`)

        const receipt = await tx.wait()
        console.log(`‚úÖ Keeper ticket purchased in block ${receipt.blockNumber}`)

        // Calculate gas cost
        const gasUsed = receipt.gasUsed
        const gasPrice = receipt.gasPrice || tx.gasPrice
        const gasCostWei = gasUsed * gasPrice
        const gasCostPls = ethers.formatEther(gasCostWei)
        console.log(`‚õΩ Gas Used: ${gasUsed.toString()} units`)
        console.log(`üí∏ Gas Cost: ${gasCostPls} PLS`)

        // Get current round info to show what happened
        try {
          const info = await lottery.getCurrentRoundInfo()
          const roundId = info[0]
          const timeRemaining = Number(info[6])
          const totalTickets = Number(info[4])
          const uniquePlayers = Number(info[5])

          console.log(`üìä Current Round Status:`)
          console.log(`   Round ID: ${roundId.toString()}`)
          console.log(`   Time Remaining: ${timeRemaining}s`)
          console.log(`   Total Tickets: ${totalTickets}`)
          console.log(`   Unique Players: ${uniquePlayers}`)
        } catch (infoErr) {
          console.log(`‚ö†Ô∏è Could not fetch round info: ${infoErr.message}`)
        }

      } else {
        console.log(`‚ö†Ô∏è Keeper low on funds - cannot buy ticket`)
        console.log(`   Required: ${ethers.formatUnits(ticketPrice, 18)} MORBIUS`)
        console.log(`   Available: ${ethers.formatUnits(keeperBalance, 18)} MORBIUS`)
      }

      console.log('‚ïê'.repeat(50) + '\n')
      consecutiveErrors = 0

    } catch (err) {
      console.error(`‚ùå Keeper ticket purchase failed:`, err.message)
      consecutiveErrors++
      if (consecutiveErrors >= MAX_CONSECUTIVE_ERRORS) {
        console.error(`‚ùå Too many consecutive errors. Stopping keeper.`)
        clearInterval(ticketInterval)
        process.exit(1)
      }
    }
  }, TICKET_INTERVAL_MS)

  // Handle graceful shutdown
  process.on('SIGINT', () => {
    console.log('\nüõë Received shutdown signal. Stopping keeper...')
    clearInterval(ticketInterval)
    process.exit(0)
  })

  process.on('SIGTERM', () => {
    console.log('\nüõë Received termination signal. Stopping keeper...')
    clearInterval(ticketInterval)
    process.exit(0)
  })
}

main().catch((err) => {
  console.error('üí• Fatal error:', err)
  process.exit(1)
})

async function main() {
  const provider = new ethers.JsonRpcProvider(RPC_URL)
  const wallet = new ethers.Wallet(PRIVATE_KEY, provider)
  const lottery = new ethers.Contract(LOTTERY_ADDRESS, ABI, wallet)

  const MORBIUS_TOKEN_ADDRESS = '0xB7d4eB5fDfE3d4d3B5C16a44A49948c6EC77c6F1'
  const ERC20_ABI = [
    'function balanceOf(address) view returns (uint256)',
    'function symbol() view returns (string)',
    'function decimals() view returns (uint8)',
    'function allowance(address owner, address spender) view returns (uint256)',
    'function approve(address spender, uint256 amount) returns (bool)'
  ]
  const morbiusToken = new ethers.Contract(MORBIUS_TOKEN_ADDRESS, ERC20_ABI, provider)

  // Get initial balances
  try {
    const morbiusBalance = await morbiusToken.balanceOf(wallet.address)
    const plsBalance = await provider.getBalance(wallet.address)
    console.log('ü§ñ Lottery Keeper Started')
    console.log('‚îÅ'.repeat(50))
    console.log(`Keeper Address: ${wallet.address}`)
    console.log(`Contract: ${LOTTERY_ADDRESS}`)
    console.log(`RPC: ${RPC_URL}`)
    console.log('üí∞ Initial Balances:')
    console.log(`   PLS: ${ethers.formatEther(plsBalance)} PLS`)
    console.log(`   Morbius: ${ethers.formatUnits(morbiusBalance, 18)} MORBIUS`)
    console.log('‚îÅ'.repeat(50) + '\n')
  } catch (err) {
    console.error('‚ö†Ô∏è  Could not fetch initial balances:', err.message, '\n')
  }

  let consecutiveErrors = 0
  const MAX_CONSECUTIVE_ERRORS = 10

  // Buy ticket every 135 seconds (2:15 minutes)
  const TICKET_INTERVAL_MS = 135000

  console.log(`üé´ Keeper will buy tickets every ${TICKET_INTERVAL_MS / 1000} seconds`)
  console.log('‚ïê'.repeat(50) + '\n')

  // Set up recurring ticket purchases
  const ticketInterval = setInterval(async () => {
    try {
      console.log(`\n${'‚ïê'.repeat(50)}`)
      console.log(`üé´ BUYING KEEPER TICKET - ${new Date().toLocaleString()}`)
      console.log('‚ïê'.repeat(50))

      // Check keeper balance
      const keeperBalance = await morbiusToken.balanceOf(wallet.address)
      const ticketPrice = await lottery.ticketPriceMorbius()

      console.log(`üí∞ Keeper Balance: ${ethers.formatUnits(keeperBalance, 18)} MORBIUS`)
      console.log(`üé´ Ticket Price: ${ethers.formatUnits(ticketPrice, 18)} MORBIUS`)

      if (keeperBalance >= ticketPrice) {
        console.log(`üõ°Ô∏è Purchasing keeper ticket...`)

        // Check if lottery contract is approved to spend keeper's Morbius
        const currentAllowance = await morbiusToken.allowance(wallet.address, LOTTERY_ADDRESS)
        console.log(`üîì Current Allowance: ${ethers.formatUnits(currentAllowance, 18)} MORBIUS`)

        if (currentAllowance < ticketPrice) {
          console.log(`üìù Approving lottery contract to spend Morbius...`)
          const approveTx = await morbiusToken.connect(wallet).approve(LOTTERY_ADDRESS, ethers.MaxUint256)
          console.log(`üìù Approval Transaction: ${approveTx.hash}`)
          await approveTx.wait()
          console.log(`‚úÖ Approval confirmed`)
        }

        // Generate random numbers for keeper ticket
        const keeperTicketNumbers = generateRandomTicketNumbers()
        const keeperNumbers = [keeperTicketNumbers]

        console.log(`üé≤ Keeper Ticket Numbers: [${keeperTicketNumbers.join(', ')}]`)

        // This will automatically finalize expired rounds and start new ones
        const tx = await lottery.buyTickets(keeperNumbers, { gasLimit: GAS_LIMIT })
        console.log(`üìù Transaction: ${tx.hash}`)
        console.log(`‚è≥ Waiting for confirmation...`)

        const receipt = await tx.wait()
        console.log(`‚úÖ Keeper ticket purchased in block ${receipt.blockNumber}`)

        // Calculate gas cost
        const gasUsed = receipt.gasUsed
        const gasPrice = receipt.gasPrice || tx.gasPrice
        const gasCostWei = gasUsed * gasPrice
        const gasCostPls = ethers.formatEther(gasCostWei)
        console.log(`‚õΩ Gas Used: ${gasUsed.toString()} units`)
        console.log(`üí∏ Gas Cost: ${gasCostPls} PLS`)

        // Get current round info to show what happened
        try {
          const info = await lottery.getCurrentRoundInfo()
          const roundId = info[0]
          const timeRemaining = Number(info[6])
          const totalTickets = Number(info[4])
          const uniquePlayers = Number(info[5])

          console.log(`üìä Current Round Status:`)
          console.log(`   Round ID: ${roundId.toString()}`)
          console.log(`   Time Remaining: ${timeRemaining}s`)
          console.log(`   Total Tickets: ${totalTickets}`)
          console.log(`   Unique Players: ${uniquePlayers}`)
        } catch (infoErr) {
          console.log(`‚ö†Ô∏è Could not fetch round info: ${infoErr.message}`)
        }

      } else {
        console.log(`‚ö†Ô∏è Keeper low on funds - cannot buy ticket`)
        console.log(`   Required: ${ethers.formatUnits(ticketPrice, 18)} MORBIUS`)
        console.log(`   Available: ${ethers.formatUnits(keeperBalance, 18)} MORBIUS`)
      }

      console.log('‚ïê'.repeat(50) + '\n')
      consecutiveErrors = 0

    } catch (err) {
      console.error(`‚ùå Keeper ticket purchase failed:`, err.message)
      consecutiveErrors++
      if (consecutiveErrors >= MAX_CONSECUTIVE_ERRORS) {
        console.error(`‚ùå Too many consecutive errors. Stopping keeper.`)
        clearInterval(ticketInterval)
        process.exit(1)
      }
    }
  }, TICKET_INTERVAL_MS)

  // Handle graceful shutdown
  process.on('SIGINT', () => {
    console.log('\nüõë Received shutdown signal. Stopping keeper...')
    clearInterval(ticketInterval)
    process.exit(0)
  })

  process.on('SIGTERM', () => {
    console.log('\nüõë Received termination signal. Stopping keeper...')
    clearInterval(ticketInterval)
    process.exit(0)
  })
}

main().catch((err) => {
  console.error('üí• Fatal error:', err)
  process.exit(1)
})

async function main() {
  const provider = new ethers.JsonRpcProvider(RPC_URL)
  const wallet = new ethers.Wallet(PRIVATE_KEY, provider)
  const lottery = new ethers.Contract(LOTTERY_ADDRESS, ABI, wallet)

  // Track Morbius balance for keeper rewards
  let lastMorbiusBalance = BigInt(0)
  let morbiusEarned = BigInt(0)

  console.log('ü§ñ Lottery Keeper Started')
  console.log('‚îÅ'.repeat(50))
  console.log(`Keeper Address: ${wallet.address}`)
  console.log(`Contract: ${LOTTERY_ADDRESS}`)
  console.log(`RPC: ${RPC_URL}`)
  console.log(`Poll Interval: ${POLL_MS}ms`)
  console.log('‚îÅ'.repeat(50))

  // Verify contract is accessible
  try {
    const code = await provider.getCode(LOTTERY_ADDRESS)
    if (code === '0x') {
      console.error('‚ùå No contract found at address:', LOTTERY_ADDRESS)
      process.exit(1)
    }
    console.log('‚úÖ Contract verified at address\n')
  } catch (err) {
    console.error('‚ùå Failed to connect to contract:', err.message)
    process.exit(1)
  }

  // Get Morbius token contract
  const MORBIUS_TOKEN_ADDRESS = '0xB7d4eB5fDfE3d4d3B5C16a44A49948c6EC77c6F1'
  const ERC20_ABI = [
    'function balanceOf(address) view returns (uint256)',
    'function symbol() view returns (string)',
    'function decimals() view returns (uint8)',
    'function allowance(address owner, address spender) view returns (uint256)',
    'function approve(address spender, uint256 amount) returns (bool)'
  ]
  const morbiusToken = new ethers.Contract(MORBIUS_TOKEN_ADDRESS, ERC20_ABI, provider)

  // Get initial balances
  try {
    lastMorbiusBalance = await morbiusToken.balanceOf(wallet.address)
    const plsBalance = await provider.getBalance(wallet.address)
    console.log('üí∞ Initial Balances:')
    console.log(`   PLS: ${ethers.formatEther(plsBalance)} PLS`)
    console.log(`   Morbius: ${ethers.formatUnits(lastMorbiusBalance, 18)} MORBIUS\n`)
  } catch (err) {
    console.error('‚ö†Ô∏è  Could not fetch initial balances:', err.message, '\n')
  }

  let consecutiveErrors = 0
  const MAX_CONSECUTIVE_ERRORS = 10
  let lastRoundId = null
  let lastState = null

  // Buy ticket every 135 seconds (2:15 minutes)
  const TICKET_INTERVAL_MS = 135000

  console.log(`üé´ Keeper will buy tickets every ${TICKET_INTERVAL_MS / 1000} seconds`)
  console.log('‚ïê'.repeat(50) + '\n')

  // Set up recurring ticket purchases
  const ticketInterval = setInterval(async () => {
    try {
      console.log(`\n${'‚ïê'.repeat(50)}`)
      console.log(`üé´ BUYING KEEPER TICKET - ${new Date().toLocaleString()}`)
      console.log('‚ïê'.repeat(50))

      // getCurrentRoundInfo returns tuple:
      // roundId, startTime, endTime, totalPssh, totalTickets,
      // uniquePlayers, timeRemaining, isMegaMillionsRound, state
      const roundId = info[0]
      const startTime = Number(info[1])
      const endTime = Number(info[2])
      const totalPssh = info[3]
      const totalTickets = Number(info[4])
      const uniquePlayers = Number(info[5])
      const timeRemaining = Number(info[6])
      const isMegaMillions = info[7]
      const state = Number(info[8]) // 0=OPEN,1=FINALIZED
      const stateLabel = ['OPEN', 'FINALIZED'][state] || `UNKNOWN(${state})`

      // Detect round changes
      const roundChanged = lastRoundId !== null && roundId !== lastRoundId
      const stateChanged = lastState !== null && lastState !== state

      if (roundChanged || lastRoundId === null) {
        console.log('\n' + '‚ïê'.repeat(50))
        console.log(`üé∞ NEW ROUND STARTED`)
        console.log('‚ïê'.repeat(50))
        console.log(`   Round ID: ${roundId.toString()}`)
        console.log(`   Type: ${isMegaMillions ? '‚≠ê MEGA MORBIUS' : 'Standard'}`)
        console.log(`   Start: ${new Date(startTime * 1000).toLocaleString()}`)
        console.log(`   End: ${new Date(endTime * 1000).toLocaleString()}`)
        console.log(`   Duration: ${Math.floor((endTime - startTime) / 60)} minutes`)

        // üõ°Ô∏è BUY KEEPER TICKET TO PREVENT EMPTY ROUND
        try {
          const keeperBalance = await morbiusToken.balanceOf(wallet.address)
          const ticketPrice = await lottery.ticketPriceMorbius()

          console.log(`   üí∞ Keeper Balance: ${ethers.formatUnits(keeperBalance, 18)} MORBIUS`)
          console.log(`   üé´ Ticket Price: ${ethers.formatUnits(ticketPrice, 18)} MORBIUS`)

          if (keeperBalance >= ticketPrice) {
            console.log(`   üõ°Ô∏è Keeper buying ticket to ensure round activity...`)

            // Check if lottery contract is approved to spend keeper's Morbius
            const currentAllowance = await morbiusToken.allowance(wallet.address, LOTTERY_ADDRESS)
            console.log(`   üîì Current Allowance: ${ethers.formatUnits(currentAllowance, 18)} MORBIUS`)

            if (currentAllowance < ticketPrice) {
              console.log(`   üìù Approving lottery contract to spend Morbius...`)
              const approveTx = await morbiusToken.connect(wallet).approve(LOTTERY_ADDRESS, ethers.MaxUint256)
              console.log(`   üìù Approval Transaction: ${approveTx.hash}`)
              await approveTx.wait()
              console.log(`   ‚úÖ Approval confirmed`)
            }

            // Generate random numbers for keeper ticket
            const keeperTicketNumbers = generateRandomTicketNumbers()
            const keeperNumbers = [keeperTicketNumbers]

            console.log(`   üé≤ Keeper Ticket Numbers: [${keeperTicketNumbers.join(', ')}]`)

            const tx = await lottery.buyTickets(keeperNumbers, { gasLimit: GAS_LIMIT })
            console.log(`   üìù Transaction: ${tx.hash}`)
            console.log(`   ‚è≥ Waiting for confirmation...`)

            const receipt = await tx.wait()
            console.log(`   ‚úÖ Keeper ticket purchased in block ${receipt.blockNumber}`)

            // Calculate gas cost
            const gasUsed = receipt.gasUsed
            const gasPrice = receipt.gasPrice || tx.gasPrice
            const gasCostWei = gasUsed * gasPrice
            const gasCostPls = ethers.formatEther(gasCostWei)
            console.log(`   ‚õΩ Gas Used: ${gasUsed.toString()} units`)
            console.log(`   üí∏ Gas Cost: ${gasCostPls} PLS`)
          } else {
            console.log(`   ‚ö†Ô∏è  Keeper low on funds - cannot buy ticket`)
            console.log(`      Required: ${ethers.formatUnits(ticketPrice, 18)} MORBIUS`)
            console.log(`      Available: ${ethers.formatUnits(keeperBalance, 18)} MORBIUS`)
          }
        } catch (err) {
          console.error(`   ‚ö†Ô∏è  Keeper ticket purchase failed:`, err.message)
        }

        console.log('‚ïê'.repeat(50) + '\n')
      } else if (stateChanged && state === 2) {
        console.log('\n' + '‚ïê'.repeat(50))
        console.log(`üèÅ ROUND FINALIZED`)
        console.log('‚ïê'.repeat(50))
        console.log(`   Round ID: ${roundId.toString()}`)
        console.log(`   Total Tickets: ${totalTickets}`)
        console.log(`   Unique Players: ${uniquePlayers}`)
        console.log(`   Total Pool: ${ethers.formatUnits(totalPssh, 18)} pSSH`)
        console.log(`   Finalized: ${new Date().toLocaleString()}`)
        console.log('‚ïê'.repeat(50) + '\n')
      }

      // Regular status log
      const timestamp = new Date().toISOString().split('T')[1].split('.')[0]
      console.log(
        `[${timestamp}] Round ${roundId.toString()} | ${stateLabel} | ‚è±Ô∏è  ${timeRemaining}s | üé´ ${totalTickets} tickets | üë• ${uniquePlayers} players`
      )

      const roundExpired = timeRemaining <= 0
      const roundOpen = state === 0

      // Handle OPEN rounds that have expired (finalize and draw immediately)
      if (roundOpen && roundExpired) {
        console.log(`\nüé´ Finalizing round ${roundId.toString()}...`)
        
        // Double-check contract state before attempting
        let shouldFinalize = false
        try {
          const currentBlock = await provider.getBlockNumber()
          const blockData = await provider.getBlock(currentBlock)
          const blockTimestamp = blockData.timestamp
          const contractState = await lottery.currentRoundState()
          const startTime = await lottery.currentRoundStartTime()
          const duration = await lottery.roundDuration()
          const currentTime = Math.floor(Date.now() / 1000)
          
          // Convert BigInt to number for comparison
          const stateNum = Number(contractState)
          const expiryTime = Number(startTime) + Number(duration)
          
          console.log(`   üîç Pre-flight check:`)
          console.log(`      Block: ${currentBlock}`)
          console.log(`      Block timestamp: ${blockTimestamp} (blockchain time)`)
          console.log(`      System time: ${currentTime} (local time)`)
          console.log(`      Time diff: ${currentTime - Number(blockTimestamp)}s`)
          console.log(`      Contract state: ${stateNum} (0=OPEN, 1=FINALIZED)`)
          console.log(`      Round start: ${startTime}`)
          console.log(`      Duration: ${duration}s`)
          console.log(`      Expires at: ${expiryTime}`)
          console.log(`      Expired (blockchain time): ${Number(blockTimestamp) >= expiryTime}`)
          console.log(`      Expired (system time): ${currentTime >= expiryTime}`)
          
          if (stateNum !== 0) {
            console.log(`   ‚ö†Ô∏è  Round already finalized or locked. Skipping.`)
            consecutiveErrors = 0
          } else if (Number(blockTimestamp) < expiryTime) {
            console.log(`   ‚ö†Ô∏è  Round not expired yet according to blockchain time. Skipping.`)
            consecutiveErrors = 0
          } else {
            console.log(`   ‚úÖ Pre-flight passed, proceeding with finalization...`)
            shouldFinalize = true
          }
        } catch (checkErr) {
          console.error(`   ‚ö†Ô∏è  Pre-flight check failed:`, checkErr.message)
          shouldFinalize = false
        }
        
        if (shouldFinalize) {
          try {
            const tx = await lottery.finalizeRound({ gasLimit: GAS_LIMIT })
            console.log(`   üìù Transaction: ${tx.hash}`)
            console.log(`   ‚è≥ Waiting for confirmation...`)
            const receipt = await tx.wait()
            console.log(`   ‚úÖ Finalized in block ${receipt.blockNumber}`)

            // Calculate gas cost
            const gasUsed = receipt.gasUsed
            const gasPrice = receipt.gasPrice || tx.gasPrice
            const gasCostWei = gasUsed * gasPrice
            const gasCostPls = ethers.formatEther(gasCostWei)

            console.log(`   ‚õΩ Gas Used: ${gasUsed.toString()} units`)
            console.log(`   üí∏ Gas Cost: ${gasCostPls} PLS`)

            // Get finalized round details
            try {
              const finalizedRound = await lottery.getRound(roundId)
              const winningNumbers = Array.from(finalizedRound.winningNumbers).map(n => Number(n))
              const totalCollected = finalizedRound.totalMorbiusCollected

              console.log(`\n   üé≤ Winning Numbers: ${winningNumbers.join(', ')}`)
              console.log(`   üé´ Total Tickets: ${finalizedRound.totalTickets.toString()}`)
              console.log(`   üë• Unique Players: ${finalizedRound.uniquePlayers.toString()}`)
              console.log(`   üí∞ Total Collected: ${ethers.formatUnits(totalCollected, 18)} MORBIUS`)

              // Calculate fund distribution (per ticket purchase)
              const deployerFee = (totalCollected * BigInt(500)) / BigInt(10000)  // 5%
              const burnAmount = (totalCollected * BigInt(1000)) / BigInt(10000)  // 10%
              const megaAmount = (totalCollected * BigInt(1000)) / BigInt(10000)  // 10%
              const winnersPool = (totalCollected * BigInt(7000)) / BigInt(10000) // 70%

              console.log(`   üìä Fund Distribution (95% of collected Morbius):`)
              console.log(`      üè¢ Deployer Fee: ${ethers.formatUnits(deployerFee, 18)} MORBIUS (5%)`)
              console.log(`      üî• Burn: ${ethers.formatUnits(burnAmount, 18)} MORBIUS (10%)`)
              console.log(`      üíé Mega Bank: ${ethers.formatUnits(megaAmount, 18)} MORBIUS (10%)`)
              console.log(`      üèÜ Winners Pool: ${ethers.formatUnits(winnersPool, 18)} MORBIUS (70%)`)
              console.log(`      ü§ñ Keeper Fee: ${ethers.formatUnits(totalCollected * BigInt(500) / BigInt(10000), 18)} MORBIUS equivalent in PLS (5%)`)
            } catch (roundErr) {
              console.log(`   ‚ö†Ô∏è  Could not fetch round details: ${roundErr.message}`)
            }

            // Get updated balances
            try {
              const plsBalance = await provider.getBalance(wallet.address)
              const newMorbiusBalance = await morbiusToken.balanceOf(wallet.address)
              morbiusEarned = newMorbiusBalance - lastMorbiusBalance
              const totalMorbius = newMorbiusBalance

              // Estimate remaining draws
              const avgGasCost = BigInt(gasCostWei)
              const estimatedDrawsLeft = avgGasCost > 0 ? plsBalance / avgGasCost : 0n

              console.log(`\n   ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê`)
              console.log(`   üíº KEEPER WALLET STATUS`)
              console.log(`   ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê`)
              console.log(`   üíé PLS Balance: ${ethers.formatEther(plsBalance)} PLS`)
              console.log(`   üìä Estimated Draws Remaining: ${estimatedDrawsLeft.toString()} draws`)
              console.log(`   `)
              console.log(`   ü™ô Morbius Balance: ${ethers.formatUnits(totalMorbius, 18)} MORBIUS`)
              if (morbiusEarned > 0) {
                console.log(`   ‚ú® Morbius Earned This Round: +${ethers.formatUnits(morbiusEarned, 18)} MORBIUS`)
              } else if (morbiusEarned < 0) {
                console.log(`   ‚ö†Ô∏è  Morbius Change: ${ethers.formatUnits(morbiusEarned, 18)} MORBIUS`)
              }
              console.log(`   ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n`)

              lastMorbiusBalance = newMorbiusBalance
            } catch (balanceErr) {
              console.log(`   ‚ö†Ô∏è  Could not fetch updated balances: ${balanceErr.message}\n`)
            }

            consecutiveErrors = 0
          } catch (finalizeErr) {
            const reason = finalizeErr.reason || finalizeErr.message || finalizeErr
            console.error(`   ‚ùå Finalize error:`, reason)
            if (finalizeErr.receipt) {
              console.error(`   Status: ${finalizeErr.receipt.status} | Gas used: ${finalizeErr.receipt.gasUsed}`)
            }
            if (finalizeErr.data) {
              console.error(`   Error data:`, finalizeErr.data)
            }
            consecutiveErrors++
          }
        }
      }
  }, TICKET_INTERVAL_MS)

  // Handle graceful shutdown
  process.on('SIGINT', () => {
    console.log('\nüõë Received shutdown signal. Stopping keeper...')
    clearInterval(ticketInterval)
    process.exit(0)
  })

  process.on('SIGTERM', () => {
    console.log('\nüõë Received termination signal. Stopping keeper...')
    clearInterval(ticketInterval)
    process.exit(0)
  })
}

main().catch((err) => {
  console.error('üí• Fatal error:', err)
  process.exit(1)
})

